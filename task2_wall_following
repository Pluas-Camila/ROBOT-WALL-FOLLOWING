# task2_wall_follow_hambot_min.py
# -------------------------------------------------------------
# HamBot Task 2: Minimal & steady wall-follow (left or right)
# - Uses ONE side ray (PID) + ONE front ray (corner turn)
# - FOLLOW state: forward RPM fixed, small PI steer (keeps both wheels forward)
# - TURN state: fixed 0.65 s in-place spin toward chosen wall
# - Hysteresis + cooldown on front detection to avoid spin-go-spin pattern
# -------------------------------------------------------------

import time, math
from robot_systems.robot import HamBot

# ====== Choose wall side ======
FOLLOW_SIDE = 'left'              # 'left' or 'right'
SIDE_SIGN   = (+1.0 if FOLLOW_SIDE == 'left' else -1.0)

# ====== LIDAR indices (0: back, 90: left, 180: front, 270: right) ======
FRONT_IDX = 180
SIDE_IDX  =  90 if FOLLOW_SIDE == 'left' else 270
MM_TO_M   = 1.0 / 1000.0

# ====== Control period ======
DT = 0.032

# ====== Targets & thresholds (meters) ======
TARGET_OFFSET      = 0.30    # desired distance from wall
# Front hysteresis: smaller "ON", larger "OFF"
FRONT_BLOCK_ON     = 0.30    # enter TURN if front < 0.30 m (after debounce)
FRONT_BLOCK_OFF    = 0.36    # consider cleared when front > 0.36 m
FRONT_DEBOUNCE_N   = 4       # frames below ON to trigger a turn
TURN_COOLDOWN_SEC  = 1.8     # ignore front trigger for a bit after turning
EMERGENCY_STOP     = 0.12    # hard stop if dangerously close

# ====== Motors ======
RPM_MAX            = 75.0
BASE_RPM           = 45.0     # forward RPM in FOLLOW
FOLLOW_TURN_FRAC   = 0.45     # keep |turn| <= frac * forward -> both wheels stay forward
TURN_RPM_FIXED     = 50.0     # in-place spin RPM (TURN state)
TURN_DURATION_S    = 0.65     # hard-coded ~90° spin (coarse but OK)

# ====== Side PI (steering) in RPM units ======
Kp_turn            = 120.0    # smaller = straighter; larger = tighter to wall
Ki_turn            =   6.0    # small integral to remove bias
I_CLAMP            =  80.0    # limit integral contribution
E_DB               = 0.01     # do not integrate tiny noise

def clamp(x, lo, hi): return max(lo, min(hi, x))

def get_m(scan, idx, last=None):
    if scan == -1 or len(scan) <= idx:
        return last
    v = float(scan[idx])
    if not math.isfinite(v) or v <= 0.0:
        return last
    return v * MM_TO_M

def spin_fixed(bot: HamBot, direction: str, rpm=TURN_RPM_FIXED, dur=TURN_DURATION_S):
    # In-place spin uses opposite signs on wheels
    if direction == 'left':
        bot.set_left_motor_speed(-rpm)
        bot.set_right_motor_speed(+rpm)
    else:
        bot.set_left_motor_speed(+rpm)
        bot.set_right_motor_speed(-rpm)
    time.sleep(dur)
    bot.stop_motors()
    time.sleep(0.05)

def main():
    bot = HamBot(lidar_enabled=True, camera_enabled=False)
    print(f"[Task2] {FOLLOW_SIDE.upper()} wall-follow | target={TARGET_OFFSET:.2f} m")

    # --- State ---
    mode = "FOLLOW"
    front_below_ctr = 0
    turn_cooldown_until = 0.0

    # --- PI state ---
    integ = 0.0

    # Last valid distances (hold on glitches)
    y_front = None
    y_side  = None

    try:
        while True:
            t0 = time.time()
            scan = bot.get_range_image()
            if scan == -1:
                bot.stop_motors()
                print("[WARN] LIDAR not ready…")
                time.sleep(0.1)
                continue

            # Read meters
            y_front_new = get_m(scan, FRONT_IDX, y_front)
            y_side_new  = get_m(scan, SIDE_IDX,  y_side if y_side is not None else 0.8)
            if y_front_new is None or y_side_new is None:
                bot.stop_motors()
                time.sleep(0.05)
                continue
            y_front, y_side = y_front_new, y_side_new

            # Emergency stop if front is dangerously close
            if y_front < EMERGENCY_STOP:
                print(f"[SAFE] Front too close: {y_front:.2f} m → STOP")
                bot.stop_motors()
                time.sleep(0.1)
                continue

            # -------------------
            # Mode: FOLLOW
            # -------------------
            if mode == "FOLLOW":
                # Hysteresis + debounce + cooldown for front detection
                now = time.time()
                if now >= turn_cooldown_until:
                    if y_front < FRONT_BLOCK_ON:
                        front_below_ctr += 1
                    elif y_front > FRONT_BLOCK_OFF:
                        front_below_ctr = 0
                    # else: between ON/OFF -> keep current counter (hysteresis)
                else:
                    front_below_ctr = 0  # ignore triggers during cooldown

                # Trigger turn only if sustained
                if front_below_ctr >= FRONT_DEBOUNCE_N:
                    print(f"[TURN] front={y_front:.2f} m < {FRONT_BLOCK_ON:.2f} (debounced)")
                    bot.stop_motors()
                    mode = "TURN"
                    continue

                # --- Side PI (steer) ---
                e = y_side - TARGET_OFFSET   # positive if too far from wall
                if abs(e) > E_DB:
                    integ += e * DT
                    integ = clamp(integ, -I_CLAMP/max(Ki_turn,1e-9), I_CLAMP/max(Ki_turn,1e-9))

                turn_rpm = SIDE_SIGN * (Kp_turn * e + Ki_turn * integ)

                # Forward RPM
                v_rpm = BASE_RPM

                # *** Keep both wheels forward in FOLLOW ***
                follow_turn_max = FOLLOW_TURN_FRAC * v_rpm
                turn_rpm = clamp(turn_rpm, -follow_turn_max, follow_turn_max)

                # Mix so +turn (for LEFT) bends LEFT: left > right
                left_rpm  = clamp(v_rpm + turn_rpm, -RPM_MAX, RPM_MAX)
                right_rpm = clamp(v_rpm - turn_rpm, -RPM_MAX, RPM_MAX)

                bot.set_left_motor_speed(left_rpm)
                bot.set_right_motor_speed(right_rpm)

                print(f"[FOLLOW] side={y_side:.3f}m front={y_front:.3f}m e={e:+.3f} "
                      f"turn={turn_rpm:+5.1f} v={v_rpm:4.1f}  L={left_rpm:5.1f} R={right_rpm:5.1f}")

            # -------------------
            # Mode: TURN
            # -------------------
            elif mode == "TURN":
                spin_fixed(bot, direction=FOLLOW_SIDE, rpm=TURN_RPM_FIXED, dur=TURN_DURATION_S)
                # Reset PI & debounce, and start a cooldown window
                integ = 0.0
                front_below_ctr = 0
                turn_cooldown_until = time.time() + TURN_COOLDOWN_SEC
                mode = "FOLLOW"
                print("[MODE] TURN → FOLLOW (cooldown active)")

            # Pace loop to DT
            elapsed = time.time() - t0
            if elapsed < DT:
                time.sleep(DT - elapsed)

    except KeyboardInterrupt:
        print("\n[Task2] Stopping…")
    finally:
        bot.stop_motors()

if __name__ == "__main__":
    main()
