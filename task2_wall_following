# task2_wall_follow_hambot.py
# Lab 2 – Task 2 (HamBot): PID Wall Following (Left/Right) with LIDAR
# --------------------------------------------------------------------
# Exceeds-level behaviors:
#  ✓ Smooth PID on side distance (offset tracking)
#  ✓ Reliable 90° corners + sharp edges (wrap-around)
#  ✓ Left & Right modes work consistently

import math, time, argparse
from robot_systems.robot import HamBot

# ===== Robot geometry / limits =====
R_WHEEL = 0.045   # m
AXLE_L  = 0.184   # m
RPM_MAX = 75.0
RPM_MIN = -75.0

# ===== Body speed caps (converted to RPM at send time) =====
V_CRUISE = 0.25   # m/s forward nominal
V_MAX    = 0.30   # m/s cap
W_MAX    = 3.00   # rad/s yaw cap

# ===== LIDAR indices (FAIRIS/your lab convention) =====
IDX_BACK  = 0
IDX_LEFT  = 90
IDX_FRONT = 180
IDX_RIGHT = 270
IDX_LDIAG = 60     # rear-ish diagonal to sense wall continuity
IDX_RDIAG = 300

# ===== Thresholds / references =====
REF_SIDE        = 0.50  # m (target offset to wall)
SLOW_FRONT_DIST = 1.20  # m
TURN_90_DIST    = 0.60  # m => perform 90° in-place turn
NO_WALL_DIST    = 2.50  # m => wrap-around to reacquire wall
DT              = 0.032 # s

# ===== Hard-coded PID gains for angular control  =====
KP = 1.8
KI = 0.0
KD = 0.12

def mps_to_rpm(v_mps: float) -> float:
    return (v_mps / (2.0 * math.pi * R_WHEEL)) * 60.0

def sector_min(ranges, center, half_span=6):
    """Min range in a small sector around index 'center' (wrap 0..359)."""
    n = len(ranges)
    vals = []
    for k in range(-half_span, half_span + 1):
        v = float(ranges[(center + k) % n])
        if v > 0:
            vals.append(v)
    return min(vals) if vals else 6.0

def saturate(x, lo, hi):
    return max(lo, min(hi, x))

class PID:
    def __init__(self, kp, ki, kd, umin=-W_MAX, umax=W_MAX):
        self.kp, self.ki, self.kd = kp, ki, kd
        self.umin, self.umax = umin, umax
        self.iacc = 0.0
        self.eprev = 0.0
        self.init = False
    def reset(self):
        self.iacc = 0.0
        self.eprev = 0.0
        self.init = False
    def update(self, r, y, dt):
        e = r - y
        self.iacc += e * dt
        d = 0.0 if not self.init else (e - self.eprev) / max(dt, 1e-6)
        self.eprev = e
        self.init = True
        u = self.kp*e + self.ki*self.iacc + self.kd*d
        return saturate(u, self.umin, self.umax), e

def body_to_wheels_rpm(v, w):
    """Map body (v,w) -> wheel linear speeds, then to RPM, with clamp."""
    vr = v + 0.5*AXLE_L*w
    vl = v - 0.5*AXLE_L*w
    rpm_r = saturate(mps_to_rpm(vr), RPM_MIN, RPM_MAX)
    rpm_l = saturate(mps_to_rpm(vl), RPM_MIN, RPM_MAX)
    return rpm_l, rpm_r

def spin_90(bot, turn_sign=+1.0):
    """
    Clean 90° in-place spin:
      - turn_sign = +1 (left-wall) -> CCW spin
      - turn_sign = -1 (right-wall) -> CW spin
    Uses constant |w| and duration T = (pi/2)/|w|.
    """
    w_spin = 0.7 * W_MAX  # conservative
    T = (math.pi / 2.0) / w_spin
    t0 = time.time()
    while time.time() - t0 < T:
        rpm_l, rpm_r = body_to_wheels_rpm(0.0, turn_sign * w_spin)
        # Note: set_left_motor_speed inverts internally for mounting, so send raw RPMs
        bot.set_left_motor_speed(rpm_l)
        bot.set_right_motor_speed(rpm_r)
        time.sleep(DT)
    # settle
    bot.stop_motors()
    time.sleep(0.1)

def wall_follow(bot, side="left"):
    """
    PID-based wall following on HamBot (LIDAR-only).
    side = 'left' or 'right'
    """
    assert side in ("left", "right")
    turn_sign = +1.0 if side == "left" else -1.0
    idx_side  = IDX_LEFT if side == "left" else IDX_RIGHT
    idx_diag  = IDX_LDIAG if side == "left" else IDX_RDIAG

    pid_w = PID(KP, KI, KD)
    print(f"\n[Task2/HamBot] {side.upper()}-wall following | ref={REF_SIDE:.2f} m | dt={DT:.3f}s")
    print(f"Gains: Kp={KP}, Ki={KI}, Kd={KD} | V_cruise={V_CRUISE:.2f} m/s")

    try:
        while True:
            t_loop = time.time()
            ranges = bot.get_range_image()
            if ranges == -1:
                print("[WARN] LIDAR not enabled or no data; stopping.")
                bot.stop_motors()
                time.sleep(0.5)
                continue

            # Measurements
            d_front = sector_min(ranges, IDX_FRONT, half_span=6)  # obst/corner
            d_side  = sector_min(ranges, idx_side,  half_span=6)  # control
            d_diag  = sector_min(ranges, idx_diag,  half_span=4)  # smoothing

            # 1) PID on side distance -> angular velocity
            w_cmd, e_side = pid_w.update(REF_SIDE, d_side, DT)

            # 2) Forward velocity scheduling (slow near obstacles/corners)
            v_cmd = V_CRUISE
            if d_front < SLOW_FRONT_DIST:
                # linear ramp between TURN_90_DIST..SLOW_FRONT_DIST
                scale = (d_front - TURN_90_DIST) / max(SLOW_FRONT_DIST - TURN_90_DIST, 1e-6)
                v_cmd = V_CRUISE * saturate(scale, 0.1, 1.0)
            if d_diag < 0.8:
                v_cmd = min(v_cmd, 0.18)

            # 3) Hard corner: 90° turn if front is very close
            if d_front < TURN_90_DIST:
                print(f"[{side}] FRONT {d_front:.2f} m → 90° turn")
                spin_90(bot, turn_sign=turn_sign)
                pid_w.reset()
                continue

            # 4) Sharp edge: lost wall on side -> wrap toward chosen wall
            if d_side > NO_WALL_DIST:
                print(f"[{side}] LOST wall (side {d_side:.2f}) → wrap")
                w_cmd = turn_sign * 1.0
                v_cmd = 0.15

            # Clamp body speeds
            v_cmd = saturate(v_cmd, 0.0, V_MAX)
            w_cmd = saturate(w_cmd, -W_MAX, W_MAX)

            # Send wheel RPMs
            rpm_l, rpm_r = body_to_wheels_rpm(v_cmd, w_cmd)
            bot.set_left_motor_speed(rpm_l)
            bot.set_right_motor_speed(rpm_r)

            # Debug
            print(f"[{side}] front={d_front:4.2f}  side={d_side:4.2f}  diag={d_diag:4.2f}  "
                  f"e={e_side:+5.3f}  v={v_cmd:.2f}  w={w_cmd:+.2f}  rpmL={rpm_l:+6.1f} rpmR={rpm_r:+6.1f}")

            # Loop pacing
            elapsed = time.time() - t_loop
            if elapsed < DT:
                time.sleep(DT - elapsed)

    except KeyboardInterrupt:
        print("\n[Task2] Stopping…")
    finally:
        bot.stop_motors()

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--side", choices=["left", "right"], required=True,
                        help="Which wall to follow.")
    args = parser.parse_args()
    bot = HamBot(lidar_enabled=True, camera_enabled=False)
    wall_follow(bot, side=args.side)

if __name__ == "__main__":
    main()
